<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>

//생성자 함수
var person = new Object();

person.eyes = 2;
person.nose = 1;
person.mouse = 1;
person.pinkger = 10;

console.dir(person)
console.log(person)

// 객체 리터럴
var computer = {
    cpu : 'Intel 2.4Ghz',
    gpu : '갤럭시 2080',
    ram : '4g',
    core : 2,
    etc : ['스피커', '마우스', '모니터'],
    start : function(){
        console.log('start')
    }
}

console.dir(computer);
console.log(computer);
console.log(computer.start());

// 생성자 함수


//Duck이라는 생성자를 만든다. 자바스크립트에서는 일반 함수와 생성자의 문법적 차이가 없다.(개인적으로 불만이다.)
//생성자와 함수를 구별하기 위해 보통 생성자의 이름은 대문자로 선언한다.
function Duck(dName, dAge){

//생성자 함수의 내부에 있는 this라는 키워드는 이 함수가 new로 호출되었을때 생성해서 리턴하는 객체를 가리키며
//this.name은 그 생성될 객체의 프로퍼티를 생성하겠다라는 의미이다.

this.name = dName;  // 생성자 함수를 호출시 전달받는 전달인자를 name이라는 프로퍼티에 할당한다.
this.age = dAge;    // 생성자 함수를 호출시 전달받는 전달인자를 age이라는 프로퍼티에 할당한다.
this.종 = '오리';

//객체 리터럴과 다르게 아래처럼은 객체 프로퍼티의 프로퍼티명을 문자열로 만들수 없다.
//this."home adress" = '디지니 랜드';

//하지만 이런식으로 객체가 유사배열인 것을 이용하여, 배열 형태로 프로퍼티를 생성할 시 문자열로 프로퍼티명을 생성할수 있다.
this["home adress"] = '디지니 랜드';

this.for = '하하하?';

this.say = function(){
        console.log('꽥 꽥');
};

}// Duck end

</script>
</body>
</html>